#pragma only_renderers d3d11 ps4 xboxone vulkan metal switch

#pragma kernel DIRECTLIGHT main=DIRECTLIGHT

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Sky/SkyUtils.hlsl"

/* Global buffers. */
#include "../../planet/PlanetRenderSettings.cs.hlsl"
#include "../../stars/StarGlobals.hlsl"
#include "../../nebulae/NebulaGlobals.hlsl"
#include "../NightSkyGlobals.hlsl"
#include "../../../celestialBodies/CelestialBodyGlobals.hlsl"
#include "../../../main/QualityGlobals.hlsl"

#include "../../../common/Mapping.hlsl"
#include "../../../common/Random.hlsl"
#include "../../../common/Geometry.hlsl"
#include "../../../atmosphere/Atmosphere.hlsl"
#include "../../../atmosphere/AtmosphereMapping.hlsl"
#include "../../../atmosphere/AtmosphereGlobalBuffers.hlsl"
#include "../../../celestialBodies/CelestialBodyDatatypes.cs.hlsl"
#include "../DirectLightRenderer.cs.hlsl"

RW_TEXTURE2D(float4, _Framebuffer_RW);

/* Star texture resolution. */
float4 _resStar;

TEXTURE2D_ARRAY(_proceduralStarTexture);
TEXTURE2D_ARRAY(_proceduralNebulaeTexture);
TEXTURECUBE(_authoredStarTexture);
TEXTURECUBE(_authoredNebulaeTexture);

/* Sadly we have to have individual textures for each celestial body, because
 * they may all have different resolutions and because they are cubemaps. */
TEXTURECUBE(_bodyAlbedoTex0);
TEXTURECUBE(_bodyAlbedoTex1);
TEXTURECUBE(_bodyAlbedoTex2);
TEXTURECUBE(_bodyAlbedoTex3);
TEXTURECUBE(_bodyAlbedoTex4);
TEXTURECUBE(_bodyAlbedoTex5);
TEXTURECUBE(_bodyAlbedoTex6);
TEXTURECUBE(_bodyAlbedoTex7);
TEXTURECUBE(_bodyEmissionTex0);
TEXTURECUBE(_bodyEmissionTex1);
TEXTURECUBE(_bodyEmissionTex2);
TEXTURECUBE(_bodyEmissionTex3);
TEXTURECUBE(_bodyEmissionTex4);
TEXTURECUBE(_bodyEmissionTex5);
TEXTURECUBE(_bodyEmissionTex6);
TEXTURECUBE(_bodyEmissionTex7);

float4 _WorldSpaceCameraPos1;
StructuredBuffer<DirectLightSettings> _settingsBuffer;

float3 sampleBodyAlbedoTexture(float3 uvw, int bodyIndex, int mipLevel) {
  switch (bodyIndex) {
    case (CELESTIALBODY_BODY0):
      return SAMPLE_TEXTURECUBE_LOD(_ExpanseBodyAlbedoTex0, s_linear_clamp_sampler, uvw, mipLevel).xyz;
    case (CELESTIALBODY_BODY1):
      return SAMPLE_TEXTURECUBE_LOD(_ExpanseBodyAlbedoTex1, s_linear_clamp_sampler, uvw, mipLevel).xyz;
    case (CELESTIALBODY_BODY2):
      return SAMPLE_TEXTURECUBE_LOD(_ExpanseBodyAlbedoTex2, s_linear_clamp_sampler, uvw, mipLevel).xyz;
    case (CELESTIALBODY_BODY3):
      return SAMPLE_TEXTURECUBE_LOD(_ExpanseBodyAlbedoTex3, s_linear_clamp_sampler, uvw, mipLevel).xyz;
    case (CELESTIALBODY_BODY4):
      return SAMPLE_TEXTURECUBE_LOD(_ExpanseBodyAlbedoTex4, s_linear_clamp_sampler, uvw, mipLevel).xyz;
    case (CELESTIALBODY_BODY5):
      return SAMPLE_TEXTURECUBE_LOD(_ExpanseBodyAlbedoTex5, s_linear_clamp_sampler, uvw, mipLevel).xyz;
    case (CELESTIALBODY_BODY6):
      return SAMPLE_TEXTURECUBE_LOD(_ExpanseBodyAlbedoTex6, s_linear_clamp_sampler, uvw, mipLevel).xyz;
    case (CELESTIALBODY_BODY7):
      return SAMPLE_TEXTURECUBE_LOD(_ExpanseBodyAlbedoTex7, s_linear_clamp_sampler, uvw, mipLevel).xyz;
    default:
      return 0;
  }
}

float3 sampleBodyEmissionTexture(float3 uvw, int bodyIndex, int mipLevel) {
  switch (bodyIndex) {
    case (CELESTIALBODY_BODY0):
      return SAMPLE_TEXTURECUBE_LOD(_ExpanseBodyEmissionTex0, s_linear_clamp_sampler, uvw, mipLevel).xyz;
    case (CELESTIALBODY_BODY1):
      return SAMPLE_TEXTURECUBE_LOD(_ExpanseBodyEmissionTex1, s_linear_clamp_sampler, uvw, mipLevel).xyz;
    case (CELESTIALBODY_BODY2):
      return SAMPLE_TEXTURECUBE_LOD(_ExpanseBodyEmissionTex2, s_linear_clamp_sampler, uvw, mipLevel).xyz;
    case (CELESTIALBODY_BODY3):
      return SAMPLE_TEXTURECUBE_LOD(_ExpanseBodyEmissionTex3, s_linear_clamp_sampler, uvw, mipLevel).xyz;
    case (CELESTIALBODY_BODY4):
      return SAMPLE_TEXTURECUBE_LOD(_ExpanseBodyEmissionTex4, s_linear_clamp_sampler, uvw, mipLevel).xyz;
    case (CELESTIALBODY_BODY5):
      return SAMPLE_TEXTURECUBE_LOD(_ExpanseBodyEmissionTex5, s_linear_clamp_sampler, uvw, mipLevel).xyz;
    case (CELESTIALBODY_BODY6):
      return SAMPLE_TEXTURECUBE_LOD(_ExpanseBodyEmissionTex6, s_linear_clamp_sampler, uvw, mipLevel).xyz;
    case (CELESTIALBODY_BODY7):
      return SAMPLE_TEXTURECUBE_LOD(_ExpanseBodyEmissionTex7, s_linear_clamp_sampler, uvw, mipLevel).xyz;
    default:
      return 0;
  }
}

/* Returns (color, hit). */
float4 shadeGround(float3 o, float3 d, out bool closeToEdge) {
  DirectLightSettings settings = _settingsBuffer[0];
  PlanetRenderSettings planet = _ExpansePlanetRenderSettings[0];
  
  closeToEdge = false;

  /* Figure out how close we are to the horizon for conditional MSAA. */
  float r = length(o);
  float mu = dot(normalize(o), d);
  float h = r - planet.radius;
  float cos_h = -Utilities::safeSqrt(h * (2 * planet.radius + h)) / (planet.radius + h);
  closeToEdge = closeToEdge || (abs(cos_h - mu) < 0.01);

  float t = Geometry::traceSphere(o, d, planet.radius);
  if (t < 0) {
    /* We failed to intersect the sphere. */
    return float4(0, 0, 0, t);
  }

  /* Don't bother shading if the ground is black. */
  if (Utilities::average(planet.groundTint.xyz) < FLT_EPSILON) {
    return float4(0, 0, 0, t);
  }

  /* Compute the worldspace surface normal. */
  float3 hitPoint = o + d * t;
  float3 n = normalize(hitPoint);

  /* Sample albedo and emission textures if we have them. */
  float3 albedo = planet.groundTint.xyz / PI;
  float3 emission = 0;
  float3 uvw = mul(planet.rotation, float4(-n, 0)).xyz;
  if (planet.hasAlbedoTexture) {
    albedo *= 2 * SAMPLE_TEXTURECUBE_LOD(_ExpansePlanetAlbedoTexture, s_linear_clamp_sampler, uvw, 0).xyz;
  }
  if (planet.hasEmissionTexture) {
    emission = planet.groundEmissionMultiplier * SAMPLE_TEXTURECUBE_LOD(_ExpansePlanetEmissionTexture, s_linear_clamp_sampler, uvw, 0).xyz;
  }

  /* We intersected the sphere and should compute lighting. */
  float3 lighting = 0;
  for (int i = 0; i < _ExpanseNumCelestialBodies; i++) {
    CelestialBodyRenderSettings body = _ExpanseCelestialBodies[i];
    float3 L = body.direction;

    // Transmittance lookups.
    // Perturb hit point away from surface to avoid self-intersection.
    SkyIntersectionData intersection = AtmosphereGeometry::traceSkyVolumeValid(hitPoint * 1.001, L, planet.radius, planet.atmosphereRadius);
    float3 startPoint = hitPoint + L * intersection.startT;
    float lightT = intersection.endT - intersection.startT;
    float2 transmittanceUV = AtmosphereMapping::mapTransmittanceCoord(length(startPoint), 
      dot(normalize(startPoint), L), planet.atmosphereRadius, planet.radius, 
      lightT, intersection.groundHit, _atmosphereSettingsBuffer[0].resT.y);
    
    lighting += body.lightColor.xyz * max(0, dot(body.direction, n))
      * Atmosphere::sampleTransmittance(transmittanceUV)
      * Atmosphere::ComputeScreenspaceTransmittance(hitPoint, L, lightT, 
            true, _atmosphereSettingsBuffer[0]);
  }

  return float4(lighting * albedo + emission, t);
}

/* Compute the luminance multiplier of a celestial body given the illuminance
 * and the cosine of half the angular extent. */
float3 computeCelestialBodyLuminanceMultiplier(float cosTheta) {
  /* Compute solid angle. */
  // TODO: this just seems like it doesn't produce satisfying results. They
  // are far too bright.
  // float solidAngle = 2.0 * PI * (1.0 - cosTheta);
  // return 1.0 / solidAngle;
  return 1.0;
}

float3 limbDarkening(float dot_L_d, float cosTheta, float amount) {
  float centerToEdge = 1.0 - abs((dot_L_d - cosTheta) / (1.0 - cosTheta));
  float mu = Utilities::safeSqrt(1.0 - centerToEdge * centerToEdge);
  float mu2 = mu * mu;
  float mu3 = mu2 * mu;
  float mu4 = mu2 * mu2;
  float mu5 = mu3 * mu2;
  float3 a0 = float3 (0.34685, 0.26073, 0.15248);
  float3 a1 = float3 (1.37539, 1.27428, 1.38517);
  float3 a2 = float3 (-2.04425, -1.30352, -1.49615);
  float3 a3 = float3 (2.70493, 1.47085, 1.99886);
  float3 a4 = float3 (-1.94290, -0.96618, -1.48155);
  float3 a5 = float3 (0.55999, 0.26384, 0.44119);
  return max(0.0, pow(abs(a0 + a1 * mu + a2 * mu2 + a3 * mu3 + a4 * mu4 + a5 * mu5), amount));
}

/* Returns (color, hit). */
float4 shadeClosestCelestialBody(float3 d, float angularTexel, out bool closeToEdge) {
  closeToEdge = false;
  DirectLightSettings settings = _settingsBuffer[0];

  /* Figure out which body is closest to us. */
  float minT = FLT_MAX;
  int minIdx = -1;
  float minDotLD = 0;
  for (int i = 0; i < _ExpanseNumCelestialBodies; i++) {
    CelestialBodyRenderSettings body = _ExpanseCelestialBodies[i];
    float dotDirection = dot(d, body.direction);
    if (body.distance < minT && dotDirection > body.cosAngularRadius) {
      minT = body.distance;
      minIdx = i;
      minDotLD = dotDirection;
    }
    /* Square the value instead of using abs(), since abs has a branch. */
    closeToEdge = closeToEdge || ((dotDirection - body.cosAngularRadius) * (dotDirection - body.cosAngularRadius)) < 1e-5;
  }

  if (minIdx < 0) {
    /* No intersection. */
    return float4(0, 0, 0, -1);
  }

  CelestialBodyRenderSettings body = _ExpanseCelestialBodies[minIdx];

  /* Compute the surface normal to the body at the shading point and the body's
   * origin in planet space, but only if the body has an emissive texture or
   * receives light. */
  float3 n = float3(0, 1, 0);
  float3 bodyOrigin = 0;
  if ((body.emissive && body.hasEmissionTexture) || body.receivesLight) {
    /* The easiest way to compute the surface normal is to intersect the body. */
    float bodyRadius = Utilities::safeSqrt(1-body.cosAngularRadius*body.cosAngularRadius) * body.distance;
    bodyOrigin = body.direction * body.distance;
    float3 planetOriginInBodyFrame = -bodyOrigin;
    float bodyT = Geometry::traceSphere(planetOriginInBodyFrame, d, bodyRadius);
    n = normalize(planetOriginInBodyFrame + bodyT * d);
  }

  /* This is what you may refer to as the "hackiest of all hacks".
   * The idea is to compute the number of pixels in the body's angular
   * extent using the angular texel extent. Then, the mip level (computed
   * in the if blocks) is the resolution of the texture divided by the pixels
   * in the body extent. However, for some reason, this doesn't work, but
   * it works quite well when you take the square root of the body's angular
   * extent. */
  float pixelsInBodyExtent = Utilities::safeSqrt(acos(body.cosAngularRadius)) / angularTexel;

  /* Compute emission. */
  float3 emission = 0;
  if (body.emissive) {
    emission = body.lightColor.xyz * body.emissionTint.xyz;
    if (body.hasEmissionTexture) {
      float3 uvw = mul(body.emissionTextureRotation, float4(n, 0)).xyz;
      float mipLevel = min((body.emissionTextureResolution.x/2) / pixelsInBodyExtent, 7);
      emission = sampleBodyEmissionTexture(-uvw, minIdx, mipLevel) * Utilities::average(body.lightColor.xyz) * body.emissionTint.xyz;
    }
    emission *= limbDarkening(minDotLD, body.cosAngularRadius, body.limbDarkening)
      * computeCelestialBodyLuminanceMultiplier(body.cosAngularRadius);
  }

  /* Compute albedo and lighting. */
  float3 lighting = 0;
  if (body.receivesLight) {
    /* We have to compute lighting from all other bodies. TODO: we don't
     * compute shadowing here, though we could try if performance allows. */
    for (int i = 0; i < _ExpanseNumCelestialBodies; i++) {
      if (i != minIdx) {
        CelestialBodyRenderSettings lightBody = _ExpanseCelestialBodies[i];
        float3 lightBodyPosition = lightBody.distance * lightBody.direction;
        float3 lightBodyDirection = normalize(lightBodyPosition - bodyOrigin);
        if (body.moonMode) {
          float cosPhi = dot(lightBodyDirection, -d);
          float sinPhi = Utilities::safeSqrt(1 - cosPhi * cosPhi);
          float tanPhi = sinPhi / Utilities::clampAboveZero(cosPhi);
          float cosThetaR = dot(-d, n);
          float cosThetaI = dot(lightBodyDirection, n);
          float mainTerm = (2 / (3 * PI)) * (1 / (1 + (saturate(cosThetaR) / saturate(cosThetaI))));
          float g = body.retrodirection;
          // This is the correct formula. However, using the intrinsic max()
          // seems to give the same result and should be *slightly* faster.
          // float retrodirective = (cosPhi < 0) ? 1 : (2 - (tanPhi / (2 * g)) * (1 - exp(-g / tanPhi)) * (3 - exp(-g / tanPhi)));
          float retrodirective = max(1, 2 - (tanPhi / (2 * g)) * (1 - exp(-g / tanPhi)) * (3 - exp(-g / tanPhi)));
          float t = body.anisotropy;
          float scattering = ((sinPhi + (PI - abs(acos(cosPhi)) * cosPhi)) / PI) + t * (1 - 0.5 * cosPhi) * (1 - 0.5 * cosPhi);
          lighting += lightBody.lightColor.xyz * max(mainTerm, 0) * retrodirective * scattering;
        } else {
          lighting += lightBody.lightColor.xyz * saturate(dot(lightBodyDirection, n));
        }
      }
    }

    float3 albedo = body.albedoTint.xyz / PI;
    if (body.hasAlbedoTexture) {
      float3 uvw = mul(body.albedoTextureRotation, float4(n, 0)).xyz;
      float mipLevel = min(pow(abs((body.albedoTextureResolution.x/2) / pixelsInBodyExtent), 0.8), 7);
      albedo *= 2 * sampleBodyAlbedoTexture(-uvw, minIdx, mipLevel);
    }

    lighting *= albedo;
  }

  return float4(lighting + emission, 1);
}

float3 shadeNightSky(float3 d, float cameraExtent) {
  DirectLightSettings settings = _settingsBuffer[0];
  NightSkyRenderSettings nightSky = _ExpanseNightSky[0];
  StarRenderSettings starSettings = _ExpanseStars[0];
  NebulaRenderSettings nebulaSettings = _ExpanseNebula[0];

  /* If we have no textures whatsoever, return 0. */
  if (!_ExpanseNebulaProcedural && !_ExpanseStarsProcedural &&
    !_ExpanseHasNebulaTexture && !_ExpanseHasStarTexture) {
    return 0;
  }

  /* Sample the nebulae. */
  float3 nebulaeColor = float3(0, 0, 0);
  float nebulaeAlpha = 0; // Default to zero so stars shine through.
  if (_ExpanseNebulaProcedural) {
    float3 dNebulae = mul(nightSky.rotation, mul(nebulaSettings.rotation, float4(d, 0))).xyz;
    float3 uvz = Mapping::directionToTex2DArrayCubemapUV(dNebulae);
    float4 nebulae = SAMPLE_TEXTURE2D_ARRAY_LOD(_proceduralNebulaeTexture, s_linear_clamp_sampler, uvz.xy, uvz.z, 0);
    nebulaeAlpha = nebulae.w;
    nebulaeColor = pow(abs(nebulae.xyz), nebulaSettings.definition) * nebulaSettings.intensity * nebulaSettings.tint.xyz * nebulaeAlpha;
  } else {
    float3 dNebulae = mul(nightSky.rotation, mul(nebulaSettings.rotation, float4(d, 0))).xyz;
    nebulaeColor = SAMPLE_TEXTURECUBE_LOD(_ExpanseTextureNebulaTexture, s_linear_clamp_sampler, dNebulae, 0).xyz * nebulaSettings.intensity * nebulaSettings.tint.xyz;
  }

  /* This mip level selection hack seems to work well enough. */
  float numTexelsInCamera = settings.resolution.x;
  float numTextureTexelsInCamera = _resStar.x * cameraExtent/(PI);
  float mipLevel = (numTextureTexelsInCamera / numTexelsInCamera);
  float3 starColor = float3(0, 0, 0);
  if (_ExpanseStarsProcedural) {
    float3 dStars = mul(nightSky.rotation, mul(starSettings.rotation, float4(d, 0))).xyz;
    float3 uvz = Mapping::directionToTex2DArrayCubemapUV(dStars);
    float4 stars = SAMPLE_TEXTURE2D_ARRAY_LOD(_proceduralStarTexture, s_linear_clamp_sampler, uvz.xy, uvz.z, mipLevel);
    starColor = stars.xyz * (1-nebulaeAlpha);
    if (starSettings.twinkle) {
      /* Smooth twinkle. */
      float starRandom = stars.w;
      float phase = 2 * PI * starRandom;
      float frequency = starSettings.twinkleFrequencyRange.x +
        (starSettings.twinkleFrequencyRange.y -  starSettings.twinkleFrequencyRange.x) * Random::random_1_1(starRandom * 1.37);
      float twinkleSmooth = max(0, starSettings.twinkleSmoothAmplitude * pow(sin(frequency * _Time.y + phase), 2) + starSettings.twinkleBias);
      /* Chaotic twinkle. */
      float directionSeed = Random::random_3_1(dStars);
      phase = 2 * PI * directionSeed;
      frequency = starSettings.twinkleFrequencyRange.x +
        (starSettings.twinkleFrequencyRange.y -  starSettings.twinkleFrequencyRange.x) * Random::random_1_1(directionSeed * 1.37);
      float twinkleChaotic = max(0, starSettings.twinkleChaoticAmplitude * pow(sin(frequency * _Time.y + phase), 2) + starSettings.twinkleBias);
      starColor *= (twinkleSmooth + twinkleChaotic);
    }
  } else {
    float3 dStars = mul(nightSky.rotation, mul(starSettings.rotation, float4(d, 0))).xyz;
    starColor = SAMPLE_TEXTURECUBE_LOD(_ExpanseTextureStarTexture, s_linear_clamp_sampler, dStars, mipLevel).xyz;
  }

  return (nebulaeColor + starColor * starSettings.tint) * nightSky.tint;
}

float3 shadeDirectLight(float3 o, float3 d, float angularTexel, float cameraExtent,
  out bool closeToEdge) {
  DirectLightSettings settings = _settingsBuffer[0];
  PlanetRenderSettings planet = _ExpansePlanetRenderSettings[0];

  float3 finalColor = float3(0, 0, 0);
  /* Shade the ground. */
  bool groundCloseToEdge = false;
  bool celestialBodyCloseToEdge = false;
  float4 groundColor = shadeGround(o, d, groundCloseToEdge);
  finalColor += groundColor.xyz;
  if (groundColor.w < 0) {
    /* If we didn't hit the ground, shade a celestial body. */
    float4 celestialBodyColor = shadeClosestCelestialBody(d, angularTexel, celestialBodyCloseToEdge);
    finalColor += celestialBodyColor.xyz;
    if (celestialBodyColor.w < 0) {
      /* Finally, if we didn't hit a celestial body, shade the night sky. */
      finalColor += shadeNightSky(d, cameraExtent);
    }
  }
  closeToEdge = groundCloseToEdge || celestialBodyCloseToEdge;

  /* Compute transmittance. */
  if (Utilities::average(finalColor) > 0) {
    SkyIntersectionData intersection = AtmosphereGeometry::traceSkyVolumeValid(o, d, planet.radius, planet.atmosphereRadius);
    float3 startPoint = o + d * intersection.startT;
    float r = length(startPoint);
    float mu = dot(normalize(startPoint), d);
    float t = intersection.endT - intersection.startT;
    float2 transmittanceUV = AtmosphereMapping::mapTransmittanceCoord(r, mu,
      planet.atmosphereRadius, planet.radius, t,
      intersection.groundHit, _atmosphereSettingsBuffer[0].resT.y);
    finalColor *= Atmosphere::sampleTransmittance(transmittanceUV);
  }

  return finalColor;
}

/* x is angular texel size, y is camera angular extent. */
float2 computeAngularTexelSizeAndCameraExtent() {
  DirectLightSettings settings = _settingsBuffer[0];
  float2 clipspaceLeft = float2(0+0.5, settings.resolution.y/2.0);
  float2 clipspaceRight = float2(settings.resolution.x-0.5, settings.resolution.y/2.0);
  float3 dLeft = -GetSkyViewDirWS(clipspaceLeft);
  float3 dRight = -GetSkyViewDirWS(clipspaceRight);
  float angularExtent = acos(dot(dLeft, dRight));
  return float2(angularExtent / settings.resolution.x, angularExtent);
}

[numthreads(8, 8, 1)]
void DIRECTLIGHT(uint3 id : SV_DispatchThreadID) {
  DirectLightSettings settings = _settingsBuffer[0];
  PlanetRenderSettings planet = _ExpansePlanetRenderSettings[0];
  QualityRenderSettings quality = _ExpanseQualitySettings[0];

  /* Compute the angular texel size for mip mapping. */
  float2 angularTexelAndExtent = computeAngularTexelSizeAndCameraExtent();
  float angularTexel = angularTexelAndExtent.x;
  float extent = angularTexelAndExtent.y;

  /* Get the clipspace coordinate---in a compute shader, this is really easy,
   * since id corresponds directly to pixel coordinates! */
  float2 clipspace = id.xy + 0.5;

  /* Convert clipspace coordinate to worldspace direction. */
  float3 d = -GetSkyViewDirWS(clipspace);
  /* Convert the camera position to planet space. */
  float3 o = Mapping::transformPointToPlanetSpace(_WorldSpaceCameraPos1.xyz,
    planet.originOffset, planet.radius);

  bool closeToEdge = false;
  float3 finalColor = shadeDirectLight(o, d, angularTexel, extent, closeToEdge);

  if (quality.antiAlias && closeToEdge) {
    /* Throw out the first sample and render 8 more samples in an MSAA
     * pattern. */
    finalColor = 0;
    static const float MSAA_8X_OFFSETS_X[8] = {1.0/16.0, -1.0/16.0, 5.0/16.0, -3.0/16.0, -5.0/16.0, -7.0/16.0, 3.0/16.0, 7.0/16.0};
    static const float MSAA_8X_OFFSETS_Y[8] =  {-3.0/16.0, 3.0/16.0, 1.0/16.0, -5.0/16.0, 5.0/16.0, -1.0/16.0, 7.0/16.0, -7.0/16.0};
    for (int i = 0; i < 8; i++) {
      float3 dOffset = -GetSkyViewDirWS(clipspace + float2(MSAA_8X_OFFSETS_X[i], MSAA_8X_OFFSETS_Y[i]));
      finalColor += shadeDirectLight(o, dOffset, angularTexel, extent, closeToEdge);
    }
    finalColor /= 8.0;
  }

  /* Store it multiplied through by exposure to improve precision. */
  _Framebuffer_RW[id.xy] = float4(GetCurrentExposureMultiplier() * max(0, finalColor), 1);
}
