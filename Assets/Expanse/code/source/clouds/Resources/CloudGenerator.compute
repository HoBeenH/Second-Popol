#pragma only_renderers d3d11 ps4 xboxone vulkan metal switch

#pragma kernel CONSTANT2D main=CONSTANT2D
#pragma kernel CONSTANT3D main=CONSTANT3D
#pragma kernel VALUE2D main=VALUE2D
#pragma kernel VALUE3D main=VALUE3D
#pragma kernel PERLIN2D main=PERLIN2D
#pragma kernel PERLIN3D main=PERLIN3D
#pragma kernel WORLEY2D main=WORLEY2D
#pragma kernel WORLEY3D main=WORLEY3D
#pragma kernel INVERSEWORLEY2D main=INVERSEWORLEY2D
#pragma kernel INVERSEWORLEY3D main=INVERSEWORLEY3D
#pragma kernel PERLINWORLEY2D main=PERLINWORLEY2D
#pragma kernel PERLINWORLEY3D main=PERLINWORLEY3D
#pragma kernel PERLINWORLEY22D main=PERLINWORLEY22D
#pragma kernel PERLINWORLEY23D main=PERLINWORLEY23D
#pragma kernel CURL2D main=CURL2D
#pragma kernel CURL3D main=CURL3D

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Sky/SkyUtils.hlsl"
#include "../../common/Noise.hlsl"
#include "../../common/Utilities.hlsl"

RW_TEXTURE2D(float3, _Noise2D);
RW_TEXTURE3D(float3, _Noise3D);
float4 _res;
float4 _scale;
int _octaves;
float _octaveScale;
float _octaveMultiplier;

[numthreads(4, 4, 1)]
void CONSTANT2D(uint3 id : SV_DispatchThreadID) {
  _Noise2D[id.xy] = 1;
}
[numthreads(4, 4, 4)]
void CONSTANT3D(uint3 id : SV_DispatchThreadID) {
  _Noise3D[id] = 1;
}

[numthreads(4, 4, 1)]
void VALUE2D(uint3 id : SV_DispatchThreadID) {
  float2 uv = (id.xy + 0.5) / _res.xy;
  ValueNoise generator;
  _Noise2D[id.xy] = generator.Generate2DLayered(uv, _scale.xy, _octaveScale, _octaveMultiplier, _octaves).value.x;
}
[numthreads(4, 4, 4)]
void VALUE3D(uint3 id : SV_DispatchThreadID) {
  float3 uvw = (id + 0.5) / _res.xyz;
  ValueNoise generator;
  _Noise3D[id] = generator.Generate3DLayered(uvw, _scale.xxy, _octaveScale, _octaveMultiplier, _octaves).value.x;
}

[numthreads(4, 4, 1)]
void PERLIN2D(uint3 id : SV_DispatchThreadID) {
  float2 uv = (id.xy + 0.5) / _res.xy;
  PerlinNoise generator;
  _Noise2D[id.xy] = generator.Generate2DLayered(uv, _scale.xy, _octaveScale, _octaveMultiplier, _octaves).value.x;
}
[numthreads(4, 4, 4)]
void PERLIN3D(uint3 id : SV_DispatchThreadID) {
  float3 uvw = (id + 0.5) / _res.xyz;
  PerlinNoise generator;
  _Noise3D[id] = generator.Generate3DLayered(uvw, _scale.xxy, _octaveScale, _octaveMultiplier, _octaves).value.x;
}

[numthreads(4, 4, 1)]
void WORLEY2D(uint3 id : SV_DispatchThreadID) {
  float2 uv = (id.xy + 0.5) / _res.xy;
  WorleyNoise generator;
  _Noise2D[id.xy] = generator.Generate2DLayered(uv, _scale.xy, _octaveScale, _octaveMultiplier, _octaves).value.x;
}
[numthreads(4, 4, 4)]
void WORLEY3D(uint3 id : SV_DispatchThreadID) {
  float3 uvw = (id + 0.5) / _res.xyz;
  WorleyNoise generator;
  _Noise3D[id] = generator.Generate3DLayered(uvw, _scale.xxy, _octaveScale, _octaveMultiplier, _octaves).value.x;
}

[numthreads(4, 4, 1)]
void INVERSEWORLEY2D(uint3 id : SV_DispatchThreadID) {
  float2 uv = (id.xy + 0.5) / _res.xy;
  InverseWorleyNoise generator;
  _Noise2D[id.xy] = generator.Generate2DLayered(uv, _scale.xy, _octaveScale, _octaveMultiplier, _octaves).value.x;
}
[numthreads(4, 4, 4)]
void INVERSEWORLEY3D(uint3 id : SV_DispatchThreadID) {
  float3 uvw = (id + 0.5) / _res.xyz;
  InverseWorleyNoise generator;
  _Noise3D[id] = generator.Generate3DLayered(uvw, _scale.xxy, _octaveScale, _octaveMultiplier, _octaves).value.x;
}

[numthreads(4, 4, 1)]
void PERLINWORLEY2D(uint3 id : SV_DispatchThreadID) {
  float2 uv = (id.xy + 0.5) / _res.xy;
  WorleyNoise worleyGenerator;
  PerlinNoise perlinGenerator;
  float worley = worleyGenerator.Generate2DLayered(uv, _scale.xy*2, _octaveScale, _octaveMultiplier, _octaves).value.x;
  float perlin = perlinGenerator.Generate2DLayered(uv, _scale.xy, _octaveScale, _octaveMultiplier, _octaves).value.x;
  _Noise2D[id.xy] = NoiseUtilities::remap(perlin, worley*0.25, 1, 0, 1);
}
[numthreads(4, 4, 4)]
void PERLINWORLEY3D(uint3 id : SV_DispatchThreadID) {
  float3 uvw = (id + 0.5) / _res.xyz;
  InverseWorleyNoise worleyGenerator;
  PerlinNoise perlinGenerator;
  float worley = worleyGenerator.Generate3DLayered(uvw, _scale.xxy, _octaveScale, _octaveMultiplier, _octaves).value.x;
  float perlin = perlinGenerator.Generate3DLayered(uvw, _scale.xxy * 2, _octaveScale, _octaveMultiplier, _octaves).value.x;
  _Noise3D[id] = NoiseUtilities::remap(worley, perlin*0.25, 1, 0, 1);
}

[numthreads(4, 4, 1)]
void PERLINWORLEY22D(uint3 id : SV_DispatchThreadID) {
  float2 uv = (id.xy + 0.5) / _res.xy;
  WorleyNoise worleyGenerator;
  PerlinNoise perlinGenerator;
  float worley = worleyGenerator.Generate2DLayered(uv, _scale.xy, _octaveScale, _octaveMultiplier, _octaves).value.x;
  float perlin = perlinGenerator.Generate2DLayered(uv, _scale.xy, _octaveScale, _octaveMultiplier, _octaves).value.x;
  _Noise2D[id.xy] = NoiseUtilities::remap(perlin, (1-worley) * 0.5, 1, 0, 1);
}
[numthreads(4, 4, 4)]
void PERLINWORLEY23D(uint3 id : SV_DispatchThreadID) {
  float3 uvw = (id + 0.5) / _res.xyz;
  InverseWorleyNoise worleyGenerator;
  PerlinNoise perlinGenerator;
  float worley = worleyGenerator.Generate3DLayered(uvw, _scale.xxy, _octaveScale, _octaveMultiplier, _octaves).value.x;
  float perlin = perlinGenerator.Generate3DLayered(uvw, _scale.xxy, _octaveScale, _octaveMultiplier, _octaves).value.x;
  _Noise3D[id] = NoiseUtilities::remap(perlin, (1-worley) * 0.5, 1, 0, 1);
}

[numthreads(4, 4, 1)]
void CURL2D(uint3 id : SV_DispatchThreadID) {
  float2 uv = (id.xy + 0.5) / _res.xy;
  CurlNoise generator;
  float2 noise = generator.Generate2DLayered(uv, _scale.xy, _octaveScale, _octaveMultiplier, _octaves).value.xy;
  _Noise2D[id.xy] = float3(noise.x, noise.y, 0);
}
[numthreads(4, 4, 4)]
void CURL3D(uint3 id : SV_DispatchThreadID) {
  float3 uvw = (id + 0.5) / _res.xyz;
  CurlNoise generator;
  float3 noise = generator.Generate3DLayered(uvw, _scale.xxy, _octaveScale, _octaveMultiplier, _octaves).value.xyz;
  _Noise3D[id] = float3(noise.x, noise.y, noise.z);
}
