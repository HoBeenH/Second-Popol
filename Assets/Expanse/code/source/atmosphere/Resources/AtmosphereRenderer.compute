#pragma only_renderers d3d11 ps4 xboxone vulkan metal switch

#pragma kernel T main=T
#pragma kernel TLIGHTS main=TLIGHTS
#pragma kernel MS main=MS
#pragma kernel SKYVIEW main=SKYVIEW
#pragma kernel COMPOSITEMS main=COMPOSITEMS
#pragma kernel AP main=AP
#pragma kernel COPYDEPTH main=COPYDEPTH
#pragma kernel BLURDEPTH main=BLURDEPTH
#pragma kernel SCREENSPACE main=SCREENSPACE
#pragma kernel DENOISE_SCREENSPACE main=DENOISE_SCREENSPACE

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesFunctions.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Sky/SkyUtils.hlsl"

/* Expanse globals */
#include "../../directLight/planet/PlanetGlobals.hlsl"
#include "../../main/QualityGlobals.hlsl"
#include "../../lighting/LightingGlobals.hlsl"
#include "../AerialPerspectiveGlobals.hlsl"
#include "../AtmosphereGlobals.hlsl"

#include "../../common/Mapping.hlsl"
#include "../../common/Random.hlsl"
#include "../../common/Geometry.hlsl"
#include "../../celestialBodies/CelestialBodyDatatypes.cs.hlsl"
#include "../../clouds/CloudGlobalTextures.hlsl"
#include "../AtmosphereMapping.hlsl"
#include "../AtmosphereGeometry.hlsl"
#include "../Atmosphere.hlsl"
#include "../AtmosphereRenderer.cs.hlsl"
#include "../AtmosphereGlobalBuffers.hlsl"

RW_TEXTURE2D(float4, _T);
RW_TEXTURE2D(float4, _TLights);
RW_TEXTURE2D(float4, _MS);
RW_TEXTURE2D(float4, _MSMultithreaded);
RW_TEXTURE2D(float4, _SkyView);
RW_TEXTURE3D(float4, _AP);
RW_TEXTURE2D(float4, _DownsampledDepth);
RW_TEXTURE3D(float4, _ScreenSpace);
TEXTURE3D(_ScreenSpaceHistory);

/* Previous camera data for fog reprojection. */
float4x4 _previousViewMatrix;
float4x4 _previousProjectionMatrix;

float4 _WorldSpaceCameraPos1;
// We have to set this manually to ensure this works in the case
// that we have multiple cameras. Using the global _PixelCoordToViewDirWS
// opens us up to the possibility of that being set incorrectly.
float4x4 _PixelCoordToViewDirWS_ManualSet;

float3 computeTotalRaymarchedTransmittance(float3 o, float3 d, float t) {
  PlanetRenderSettings planet = _ExpansePlanetRenderSettings[0];
  QualityRenderSettings quality = _ExpanseQualitySettings[0];

  /* Accumulate over all non-screenspace layers. */
  float3 power = float3(0, 0, 0);
  for (int i = 0; i < _ExpanseNumAtmosphereLayers; i++) {
    AtmosphereLayerRenderSettings layer = _ExpanseAtmosphereLayers[i];
    power += Atmosphere::computeRaymarchedTransmittance(o, d, t,
      planet.radius, planet.originOffset,
      quality.samplesT, quality.importanceSample, layer);
  }

  return power;
}

[numthreads(8, 8, 1)]
void T(uint3 id : SV_DispatchThreadID) {
  AtmosphereSettings settings = _atmosphereSettingsBuffer[0];
  PlanetRenderSettings planet = _ExpansePlanetRenderSettings[0];

  /* Get the uv for this id and unwrap it to a viewing angle and a
   * height. */
  float2 u_r_mu = (id.xy + 0.5f) / settings.resT;
  float2 r_mu = AtmosphereMapping::unmapTransmittanceCoord(u_r_mu.x, u_r_mu.y,
    planet.atmosphereRadius, planet.radius, settings.resT.y);
  float r = r_mu.x;
  float mu = r_mu.y;

  float3 o = float3(0, r, 0);
  float3 d = normalize(float3(Utilities::safeSqrt(1 - mu * mu), mu, 0));

  /* Trace a ray to see what we hit. We can use traceSkyVolumeValid() since
   * our UV mapping guarantees that O will always be within the sky
   * volume. */
  SkyIntersectionData intersection = AtmosphereGeometry::traceSkyVolumeValid(o, d, planet.radius, planet.atmosphereRadius);

  /* Compute transmittance. */
  _T[id.xy] = float4(computeTotalRaymarchedTransmittance(o, d, intersection.endT), 1);
}

[numthreads(4, 1, 1)]
void TLIGHTS(uint3 id : SV_DispatchThreadID) {
  AtmosphereSettings settings = _atmosphereSettingsBuffer[0];
  PlanetRenderSettings planet = _ExpansePlanetRenderSettings[0];

  /* Light ID is x coordinate. */
  int lightID = id.x;
  DirectionalLightRenderSettings light = _ExpanseAtmosphereDirectionalLights[lightID];

  /* Sample transmittance in light direction. */
  float3 o = Mapping::transformPointToPlanetSpace(_WorldSpaceCameraPos1.xyz, planet.originOffset, planet.radius);
  SkyIntersectionData intersection = AtmosphereGeometry::traceSkyVolume(o,
    light.direction, planet.radius, planet.atmosphereRadius);
  if (intersection.groundHit) {
    /* If we hit the ground, the light is fully occluded. Set the
     * transmittance to zero. */
    _TLights[id.xy] = float4(0, 0, 0, 1);
    return;
  }
  o = o + light.direction * intersection.startT;
  float r = length(o);
  float mu = dot(normalize(o), light.direction);
  float t = intersection.endT - intersection.startT;
  float3 startPoint = o + light.direction * intersection.startT;
  float2 uv = AtmosphereMapping::mapTransmittanceCoord(r, mu, planet.atmosphereRadius,
    planet.radius, t, intersection.groundHit, settings.resT.y);

  /* Sample the screenspace transmittance. */
  float3 screenspaceTransmittance = Atmosphere::ComputeScreenspaceTransmittance(o, light.direction, t, false, settings);

  _TLights[id.xy] = float4(Atmosphere::sampleTransmittance(uv) * screenspaceTransmittance, 1);
}

[numthreads(8, 8, 1)]
void MS(uint3 id : SV_DispatchThreadID) {
  AtmosphereSettings settings = _atmosphereSettingsBuffer[0];
  PlanetRenderSettings planet = _ExpansePlanetRenderSettings[0];
  QualityRenderSettings quality = _ExpanseQualitySettings[0];

  const int ksqrtMSParallelSampleGroups = 2;
  const int kMSParallelSampleGroups = ksqrtMSParallelSampleGroups*ksqrtMSParallelSampleGroups;
  int numSamples = (1.0/(kMSParallelSampleGroups)) * quality.samplesMS;

  /* Unmap the uv coordinates to get the light direction and sample point. */
  uint2 spatialID = id.xy / ksqrtMSParallelSampleGroups;
  uint hemisphereID = (id.x % ksqrtMSParallelSampleGroups) * ksqrtMSParallelSampleGroups + (id.y % ksqrtMSParallelSampleGroups);
  float2 u_r_mu_l = (spatialID.xy + 0.5f) / settings.resMS;
  float2 r_mu_l = AtmosphereMapping::unmapMSCoordinate(u_r_mu_l.x, u_r_mu_l.y,
    planet.atmosphereRadius, planet.radius);
  float r = r_mu_l.x;
  float mu_l = r_mu_l.y;
  float3 o = float3(0, r, 0);
  float3 o_normalized = float3(0, 1, 0);
  float3 L = normalize(float3(Utilities::safeSqrt(1 - mu_l * mu_l), mu_l, 0));

  /* Sample a bunch of directions, uniformly distributed on a sphere. */
  float3 secondOrder = float3(0, 0, 0);
  float3 transferFunction = float3(0, 0, 0);
  for (int i = hemisphereID; i < quality.samplesMS; i += kMSParallelSampleGroups) {
    /* Get the sample direction. */
    float3 d = Utilities::fibonacciSphere(i, quality.samplesMS);

    /* Trace a ray to see what we hit. */
    SkyIntersectionData intersection = AtmosphereGeometry::traceSkyVolumeValid(o, d, planet.radius, planet.atmosphereRadius);
    float3 hitPoint = o + intersection.endT * d;

    /* Compute single scattering. */
    SSResult ss = Atmosphere::computeSSForMS(o, d, intersection.endT,
      intersection.endT, intersection.groundHit, L, settings);
    secondOrder += ss.shadows / (4.0 * PI);
    transferFunction += ss.noShadows;
  }

  /* Divide by number of samples we took and sphere integration term. */
  secondOrder /= 4 * PI * quality.samplesMS;
  transferFunction /= 4 * PI * quality.samplesMS;
  transferFunction = 1.0 / (1.0 - transferFunction);
  _MSMultithreaded[id.xy] = float4(secondOrder * transferFunction, 0);
}

[numthreads(8, 8, 1)]
void COMPOSITEMS(uint3 id : SV_DispatchThreadID) {
  const uint ksqrtMSParallelSampleGroups = 2;
  _MS[id.xy] = _MSMultithreaded[id.xy * ksqrtMSParallelSampleGroups]
    + _MSMultithreaded[id.xy * ksqrtMSParallelSampleGroups + uint2(0, 1)]
    + _MSMultithreaded[id.xy * ksqrtMSParallelSampleGroups + uint2(1, 0)]
    + _MSMultithreaded[id.xy * ksqrtMSParallelSampleGroups + uint2(1, 1)];
}

[numthreads(8, 8, 1)]
void SKYVIEW(uint3 id : SV_DispatchThreadID) {
  AtmosphereSettings settings = _atmosphereSettingsBuffer[0];
  PlanetRenderSettings planet = _ExpansePlanetRenderSettings[0];

  /* Get the uv for this id and unwrap it to a viewing angle and a
   * radial angle. */
  float2 u_mu_theta = (id.xy + 0.5f) / settings.resSkyView;
  float3 o = Mapping::transformPointToPlanetSpace(_WorldSpaceCameraPos1.xyz, planet.originOffset, planet.radius);
  float r = length(o);
  float2 mu_theta = AtmosphereMapping::unmapSkyRenderCoordinate(r, u_mu_theta.x, u_mu_theta.y,
    planet.atmosphereRadius, planet.radius, settings.resSkyView.x, settings.resSkyView.y);
  float3 d = AtmosphereMapping::mu_theta_to_d(mu_theta.x, mu_theta.y, o);

  /* Trace a ray to see what we hit. */
  SkyIntersectionData intersection = AtmosphereGeometry::traceSkyVolume(o, d,
    planet.radius, planet.atmosphereRadius);
  float t = intersection.endT - intersection.startT;
  float3 startPoint = o + d * intersection.startT;

  /* Compute scattering. */
  SSResult ss = Atmosphere::computeSS(startPoint, d, t, t, intersection.groundHit, false, 1, settings);
  float3 ms = Atmosphere::computeMS(startPoint, d, t, t, intersection.groundHit, 1, settings);
  _SkyView[id.xy] = float4(max(0, ss.shadows) + max(0, ms), 1);
}

[numthreads(4, 4, 8)]
void AP(uint3 id : SV_DispatchThreadID) {
  AtmosphereSettings settings = _atmosphereSettingsBuffer[0];
  AerialPerspectiveRenderSettings apSettings = _ExpanseAerialPerspectiveSettings[0];
  PlanetRenderSettings planet = _ExpansePlanetRenderSettings[0];
  QualityRenderSettings quality = _ExpanseQualitySettings[0];

  /* Get the uv for this id and unwrap it to frustum coordinates. */
  float3 uvw = (id + 0.5) / settings.resAP;
  float4 xyz = AtmosphereMapping::unmapFrustumCoordinate(uvw, settings.screenSize,
    settings.farClip, quality.AP_depthSkew, _PixelCoordToViewDirWS_ManualSet);
  float3 d = xyz.xyz;
  float depth = xyz.w;
  float3 o = Mapping::transformPointToPlanetSpace(_WorldSpaceCameraPos1.xyz, planet.originOffset, planet.radius);
  float r = length(o);

  /* Compute SS between origin and depth in direction d. */
  SkyIntersectionData intersection = AtmosphereGeometry::traceSkyVolume(o, d,
    planet.radius, planet.atmosphereRadius);

  if (depth < intersection.startT) {
    /* We're sampling at a point that hasn't even hit the beginning of the
     * atmosphere yet. */
    _AP[id] = float4(0, 0, 0, 1);
    return;
  }

  /* We're sampling at a point that has indeed hit the atmosphere. */
  float t = intersection.endT - intersection.startT;
  depth = min(depth-intersection.startT, t);

  float3 startPoint = o + d * intersection.startT;

  SSResult ss = Atmosphere::computeSS(startPoint, d, depth, t, intersection.groundHit, true, apSettings.nightScatteringMultiplier, settings);
  float3 ms = Atmosphere::computeMS(startPoint, d, depth, t, intersection.groundHit, apSettings.nightScatteringMultiplier, settings);
  /* Compute the transmittance between the 2 points. To avoid artifacts,
   * raymarch it directly---this really is no slower, according to
   * profiling. */
  float3 T = computeTotalRaymarchedTransmittance(o, d, depth);
  _AP[id] = float4(max(0, ss.shadows) + max(0, ms), Utilities::average(T));
}

[numthreads(8, 8, 1)]
void COPYDEPTH(uint3 id : SV_DispatchThreadID) {
  _DownsampledDepth[id.xy] = (Linear01Depth(LoadCameraDepth(id.xy), _ZBufferParams) < 1) ? 1 : 0;
}

[numthreads(8, 8, 1)]
void BLURDEPTH(uint3 id : SV_DispatchThreadID) {
  AtmosphereSettings settings = _atmosphereSettingsBuffer[0];
  QualityRenderSettings quality = _ExpanseQualitySettings[0];
  float stencil = 0;
  for (int i = -1; i < 2; i++) {
    for (int j = -1; j < 2; j++) {
      float2 sampleUV = (id.xy + 0.5 + float2(i, j)) / settings.resDownsampledDepth;
      stencil += SAMPLE_TEXTURE2D_LOD(_DownsampledDepthTex, s_linear_clamp_sampler, sampleUV, quality.downsampledDepthMip).x;
    }
  }
  stencil /= 9.0;
  _DownsampledDepth[id.xy] = stencil;
}

[numthreads(16, 8, 1)]
void SCREENSPACE(uint3 id : SV_DispatchThreadID) {
  AtmosphereSettings settings = _atmosphereSettingsBuffer[0];
  PlanetRenderSettings planet = _ExpansePlanetRenderSettings[0];
  QualityRenderSettings quality = _ExpanseQualitySettings[0];

  float2 uv = (id.xy + 0.5) / settings.resScreenspace.xy;

  /* Compute some things about where we are geometrically and what the
   * camera properties are. */
  float3 o = Mapping::transformPointToPlanetSpace(_WorldSpaceCameraPos1.xyz, planet.originOffset, planet.radius);
  float3 d = -Mapping::getSkyViewDirWS(uv * settings.screenSize.xy, _PixelCoordToViewDirWS_ManualSet, _TaaJitterStrength.xy);
  float r = length(o);
  float mu = dot(normalize(o), d);
  SkyIntersectionData intersection = AtmosphereGeometry::traceSkyVolume(o, d,
    planet.radius, planet.atmosphereRadius);
  float t = intersection.endT - intersection.startT;

  /* Compute the depth we should sample at for this froxel. */
  float3 cameraCenterD = -Mapping::getSkyViewDirWS(float2(settings.screenSize.x/2, settings.screenSize.y/2), _PixelCoordToViewDirWS_ManualSet, _TaaJitterStrength.xy);
  float cosTheta = dot(cameraCenterD, d);
  float farClip = settings.farClip / max(cosTheta, 0.00001);
  float depth = AtmosphereMapping::unmapFrustumW((id.z + 0.5) / (settings.resScreenspace.z), farClip, quality.screenspace_depthSkew);

  /* Sample ambient light probe. */
  const int kAmbientLightSamples = 5;
  float3 ambient = 0;
  for (int i = 0; i < kAmbientLightSamples; i++) {
    float3 fibonacciDir = Utilities::fibonacciHemisphere(i, kAmbientLightSamples);
    float muFibonacci = dot(normalize(o), fibonacciDir);
    SkyIntersectionData intersectionFibonacci = AtmosphereGeometry::traceSkyVolume(o, fibonacciDir,
      planet.radius, planet.atmosphereRadius);
    float tFibonacci = intersectionFibonacci.endT - intersectionFibonacci.startT;
    float theta = AtmosphereMapping::d_to_theta(fibonacciDir, o);
    float2 atmoUV = AtmosphereMapping::mapSkyRenderCoordinate(r, muFibonacci,
      theta, planet.atmosphereRadius, planet.radius, tFibonacci,
      intersectionFibonacci.groundHit, settings.resSkyView.x, settings.resSkyView.y);
    float4 atmosphere = SAMPLE_TEXTURE2D_LOD(_SkyViewTex, s_linear_clamp_sampler, atmoUV, 0);
    float2 cloudUV = Mapping::mapPolar(fibonacciDir);
    float4 cloudLightingAndTransmittance = SAMPLE_TEXTURE2D_LOD(_EXPANSE_CLOUD_REFLECTION, s_linear_clamp_sampler, cloudUV, 0);
    // [HACK]: to avoid the sky ambient contribution getting too blue, desaturate it!
    const float3 desaturate = 0.5;
    float3 grayscale = Utilities::average(atmosphere.xyz);
    ambient += lerp(atmosphere.xyz, grayscale, desaturate) * cloudLightingAndTransmittance.w + cloudLightingAndTransmittance.xyz;
  }
  ambient /= float(kAmbientLightSamples);

  /* Compute the scattering for the screenspace layers. */
  float3 screenspaceScattering = 0;
  float3 screenspaceTransmittance = 1;
  Atmosphere::ComputeScreenspaceScattering(o, _WorldSpaceCameraPos1.xyz, d, uv, depth, false, ambient, 
    false, settings, screenspaceScattering, screenspaceTransmittance);
  _ScreenSpace[id] = float4(screenspaceScattering, Utilities::average(screenspaceTransmittance));
}

[numthreads(16, 8, 1)]
void DENOISE_SCREENSPACE(uint3 id : SV_DispatchThreadID) {
  AtmosphereSettings settings = _atmosphereSettingsBuffer[0];
  QualityRenderSettings quality = _ExpanseQualitySettings[0];

  /* UV => worldspace direction. */
  float2 uv = (id.xy + 0.5) / settings.resScreenspace.xy;
  float3 d = -Mapping::getSkyViewDirWS(uv * settings.screenSize.xy, _PixelCoordToViewDirWS_ManualSet, _TaaJitterStrength.xy);

  /* Compute this froxel's depth. */
  float3 cameraCenterD = -Mapping::getSkyViewDirWS(float2(settings.screenSize.x/2, settings.screenSize.y/2), _PixelCoordToViewDirWS_ManualSet, _TaaJitterStrength.xy);
  float cosTheta = dot(cameraCenterD, d);
  float farClip = settings.farClip / max(cosTheta, 0.00001);
  float depth = AtmosphereMapping::unmapFrustumW((id.z + 0.5) / (settings.resScreenspace.z), farClip, quality.screenspace_depthSkew);

  /* Reproject. */
  float3 wsPosition = _WorldSpaceCameraPos1.xyz + d * depth;
  /* Transform it to clip space using the previous camera transformation. */
  float3 prevCameraSpace = mul(_previousViewMatrix, float4(wsPosition, 1)).xyz;
  float4 prevClipSpace = mul(_previousProjectionMatrix, float4(prevCameraSpace, 1));
  float2 prevNDC = prevClipSpace.xy / prevClipSpace.w;
  float2 reprojectedUV = (prevNDC + 1) / 2;

  if (Utilities::boundsCheckNoEpsilon(reprojectedUV.x, float2(0, 1)) && Utilities::boundsCheckNoEpsilon(reprojectedUV.y, float2(0, 1))) {
    float blend = 1.0/quality.screenspace_historyFrames;
    float4 historySample = SAMPLE_TEXTURE3D_LOD(_ScreenSpaceHistory, s_linear_clamp_sampler, float3(reprojectedUV, (id.z + 0.5) / (settings.resScreenspace.z)), 0);
    _ScreenSpace[id] = lerp(historySample, _ScreenSpace[id], blend);
  }
}
